package main

import (
	"bytes"
	"flag"
	"fmt"
	"path"

	"google.golang.org/protobuf/compiler/protogen"
)

var (
	fn, fpkg *string
)

func main() {
	var flags flag.FlagSet
	fn = flags.String("file", "xpc.go", "name of generated go file")
	fpkg = flags.String("pkg", "github.com/celer-network/x-proto-go/xpc", "full go package of generated file")
	protogen.Options{
		ParamFunc: flags.Set,
	}.Run(mygen)
}

func mygen(p *protogen.Plugin) error {
	xpc := p.NewGeneratedFile(path.Join(*fpkg, *fn), protogen.GoImportPath(*fpkg))
	xpc.P("package ", path.Base(*fpkg))
	xpc.P(xpcHdr)
	var streamingRpcs []*oneRpc
	for _, f := range p.Files {
		if f.Generate {
			for _, svc := range f.Services {
				svcName := svc.Desc.FullName()
				for _, rpc := range svc.Methods {
					url := fmt.Sprintf("/%s/%s", svcName, rpc.Desc.Name())

					if rpc.Desc.IsStreamingClient() || rpc.Desc.IsStreamingServer() {
						streamingRpcs = append(streamingRpcs, &oneRpc{
							URL:  url,
							Name: string(rpc.Desc.Name()),
							In:   xpc.QualifiedGoIdent(rpc.Input.GoIdent),
							Out:  xpc.QualifiedGoIdent(rpc.Output.GoIdent),
							CS:   rpc.Desc.IsStreamingClient(),
							SS:   rpc.Desc.IsStreamingServer(),
						})
						continue
					}
					xpc.P(`case "`, url, `":`)
					xpc.P(`req = new(`, rpc.Input.GoIdent, ")")
					xpc.P(`resp = new(`, rpc.Output.GoIdent, ")")
				}
			}
		}
	}
	xpc.P(xpcEnd)
	// support streaming rpcs
	var b bytes.Buffer
	streamSendTpl.Execute(&b, streamingRpcs)
	xpc.P(b.String())
	b.Reset()
	streamRecvTpl.Execute(&b, streamingRpcs)
	xpc.P(b.String())
	xpc.P(streamUtil)
	return nil
}

const xpcHdr = `// Copyright 2020 Celer Network

// Code generated by protoc-gen-xpc. DO NOT EDIT.
import (
	"context"
	"errors"

	"google.golang.org/grpc"
	"google.golang.org/protobuf/encoding/protojson"
	"google.golang.org/protobuf/proto"
)

var jm = protojson.MarshalOptions{
	UseProtoNames: true, // so assign key is same as proto field
	UseEnumNumbers: true, // so vanilla json unmarshal also works
}

func DoUnary(con grpc.ClientConnInterface, ctx context.Context, url string, in []byte) ([]byte, error) {
	var req, resp proto.Message
	switch url {
`

const xpcEnd = `
	default:
		return nil, errors.New(url + " not suppoted")
	}
	var err error
	if len(in) > 0 {
		err = protojson.Unmarshal(in, req)
		if err != nil {
			return nil, err
		}
	}
	err = con.Invoke(ctx, url, req, resp)
	if err != nil {
		return nil, err
	}
	return jm.Marshal(resp)
}
`
